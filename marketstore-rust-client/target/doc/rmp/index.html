<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Rust MessagePack Library"><title>rmp - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rmp" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rmp/index.html">rmp</a><span class="version">0.8.14</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#the-rust-messagepack-library" title="The Rust MessagePack Library">The Rust MessagePack Library</a><ul><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#features" title="Features">Features</a></li><li><a href="#detailed" title="Detailed">Detailed</a></li><li><a href="#api" title="API">API</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>rmp</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/rmp/lib.rs.html#1-14">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h3 id="the-rust-messagepack-library"><a class="doc-anchor" href="#the-rust-messagepack-library">§</a>The Rust MessagePack Library</h3>
<p>RMP is a pure Rust <a href="http://msgpack.org">MessagePack</a> implementation of an efficient binary
serialization format. This crate provides low-level core functionality, writers and readers for
primitive values with direct mapping between binary MessagePack format.</p>
<p><a href="https://lib.rs/crates/rmp-serde">Looking for Serde support</a>?</p>
<p>This crate represents the very basic functionality needed to work with MessagePack format.
Ideologically it is developed as a basis for building high-level abstractions.</p>
<h4 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h4>
<p>To use <code>rmp</code>, first add this to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.rmp]
rmp = &quot;0.8&quot;</code></pre></div><h4 id="features"><a class="doc-anchor" href="#features">§</a>Features</h4>
<ul>
<li>
<p><strong>Low-level API</strong></p>
<p>RMP is designed to be lightweight and straightforward. There are low-level APIs, which give you
full control over the encoding/decoding process. <code>no-std</code> environments are supported.</p>
</li>
<li>
<p><strong>Zero-copy value decoding</strong></p>
<p>RMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations.
easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.</p>
</li>
<li>
<p><strong>Clear error handling</strong></p>
<p>RMP’s error system guarantees that you never receive an error enum with unreachable variant.</p>
</li>
<li>
<p><strong>Robust and tested</strong></p>
<p>This project is developed using TDD and CI, so any found bugs will be fixed without breaking
existing functionality.</p>
</li>
</ul>
<h4 id="detailed"><a class="doc-anchor" href="#detailed">§</a>Detailed</h4>
<p>Currently there are two large modules: encode and decode. More detail you can find in the
corresponding sections.</p>
<p>Formally every MessagePack message consists of some marker encapsulating a data type and the
data itself. Sometimes there are no separate data chunk, for example for booleans. In these
cases a marker contains the value. For example, the <code>true</code> value is encoded as <code>0xc3</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
rmp::encode::write_bool(<span class="kw-2">&amp;mut </span>buf, <span class="bool-val">true</span>).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0xc3</span>], buf[..]);</code></pre></div>
<p>Sometimes a single value can be encoded in multiple ways. For example a value of <code>42</code> can be
represented as: <code>[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]</code> and so on, and all of them are
considered as valid representations. To allow fine-grained control over encoding such values
the library provides direct mapping functions.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bufs = <span class="macro">vec!</span>[<span class="macro">vec!</span>[]; <span class="number">5</span>];

rmp::encode::write_pfix(<span class="kw-2">&amp;mut </span>bufs[<span class="number">0</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u8(<span class="kw-2">&amp;mut </span>bufs[<span class="number">1</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u16(<span class="kw-2">&amp;mut </span>bufs[<span class="number">2</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u32(<span class="kw-2">&amp;mut </span>bufs[<span class="number">3</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u64(<span class="kw-2">&amp;mut </span>bufs[<span class="number">4</span>], <span class="number">42</span>).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0x2a</span>], bufs[<span class="number">0</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xcc</span>, <span class="number">0x2a</span>], bufs[<span class="number">1</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xcd</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>], bufs[<span class="number">2</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xce</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>], bufs[<span class="number">3</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xcf</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>], bufs[<span class="number">4</span>][..]);</code></pre></div>
<p>But they aren’t planned to be widely used. Instead we often need to encode bytes compactly to
save space. In these cases RMP provides functions that guarantee that for encoding the most
compact representation will be chosen.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

rmp::encode::write_sint(<span class="kw-2">&amp;mut </span>buf, <span class="number">300</span>).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>], buf[..]);</code></pre></div>
<p>On the other hand for deserialization it is not matter in which representation the value is
encoded - RMP deals with all of them.</p>
<p>Sometimes you know the exact type representation and want to enforce the deserialization process
to make it strongly type safe.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>buf = [<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>];

<span class="macro">assert_eq!</span>(<span class="number">300</span>, rmp::decode::read_u16(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());</code></pre></div>
<p>However if you try to decode such bytearray as other integer type, for example <code>u32</code>, there will
be type mismatch error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>buf = [<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>];
rmp::decode::read_u32(<span class="kw-2">&amp;mut &amp;</span>buf[..]).err().unwrap();</code></pre></div>
<p>But sometimes all you want is just to encode an integer that <em>must</em> fit in the specified type
no matter how it was encoded. RMP provides <a href="https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html"><code>such</code></a> function to ease integration with
other MessagePack libraries.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>buf = [<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>];

<span class="macro">assert_eq!</span>(<span class="number">300i16</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300i32</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300i64</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300u16</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300u32</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300u64</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());</code></pre></div>
<h4 id="api"><a class="doc-anchor" href="#api">§</a>API</h4>
<p>Almost all API are represented as pure functions, which accepts a generic <code>Write</code> or <code>Read</code> and
the value to be encoded/decoded. For example let’s do a round trip for π number.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>pi = std::f64::consts::PI;
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
rmp::encode::write_f64(<span class="kw-2">&amp;mut </span>buf, pi).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0xcb</span>, <span class="number">0x40</span>, <span class="number">0x9</span>, <span class="number">0x21</span>, <span class="number">0xfb</span>, <span class="number">0x54</span>, <span class="number">0x44</span>, <span class="number">0x2d</span>, <span class="number">0x18</span>], buf[..]);
<span class="macro">assert_eq!</span>(pi, rmp::decode::read_f64(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());</code></pre></div>
<p>License: MIT</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="decode/index.html" title="mod rmp::decode">decode</a></dt><dd>Provides various functions and structs for MessagePack decoding.</dd><dt><a class="mod" href="encode/index.html" title="mod rmp::encode">encode</a></dt><dd>Provides various functions and structs for MessagePack encoding.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Marker.html" title="enum rmp::Marker">Marker</a></dt><dd>Format markers.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.MSGPACK_VERSION.html" title="constant rmp::MSGPACK_VERSION">MSGPACK_<wbr>VERSION</a></dt><dd>Version of the MessagePack <a href="http://github.com/msgpack/msgpack/blob/master/spec.md">spec</a>.</dd></dl></section></div></main></body></html>