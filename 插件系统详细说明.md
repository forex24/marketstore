# MarketStore 插件系统详细说明

## 1. 插件系统概述

MarketStore提供了一个强大而灵活的插件架构，允许第三方开发者扩展核心功能。插件系统基于Go的`plugin`包实现，支持两种主要类型的插件：

- **Trigger插件（触发器插件）**：响应数据写入事件
- **BgWorker插件（后台工作插件）**：独立的后台进程

## 2. 插件架构设计

### 2.1 核心组件

```
plugins/
├── load.go          # 插件加载器
├── trigger/         # 触发器插件接口
│   └── trigger.go
├── bgworker/        # 后台工作插件接口
│   └── bgworker.go
└── README.md        # 插件开发文档
```

### 2.2 插件加载机制

插件系统使用Go的`plugin`包实现动态加载：

```go
// 插件加载器
type SymbolLoader struct {
    module *plugin.Plugin
}

// 加载插件模块
func Load(pluginName string) (pi *plugin.Plugin, err error) {
    if filepath.IsAbs(pluginName) {
        return plugin.Open(pluginName)
    }
    // 从GOPATH/bin目录加载
    for _, path := range gopaths {
        pluginPath := filepath.Join(filepath.Join(path, "bin"), pluginName)
        pi, err = plugin.Open(pluginPath)
        if err == nil {
            return pi, nil
        }
    }
    // 从当前目录加载（用于测试）
    pluginPath := filepath.Join(".", pluginName)
    return plugin.Open(pluginPath)
}
```

## 3. Trigger插件详解

### 3.1 接口定义

```go
// Trigger接口
type Trigger interface {
    // Fire在目标文件被修改时调用
    // keyPath是相对于目录根目录的修改文件的字符串路径
    // records是包含被修改行索引的切片
    Fire(keyPath string, records []Record)
}

// Record表示写入DB的序列化字节缓冲区
type Record []byte

// 必须实现的工厂函数
func NewTrigger(config map[string]interface{}) (Trigger, error)
```

### 3.2 匹配器机制

```go
// Matcher检查触发器是否应该被触发
type Matcher struct {
    Trigger Trigger
    // On是表示触发器触发事件条件的字符串
    // 它是文件路径的前缀，如"*/1Min/OHLC"
    On string
}

// Match返回true如果keyPath匹配On条件
func (tm *Matcher) Match(keyPath string) bool {
    pattern := strings.Replace(tm.On, "*", "[^/]+", -1)
    matched, _ := regexp.MatchString(pattern, keyPath)
    return matched
}
```

### 3.3 配置示例

```yaml
triggers:
  - module: ondiskagg.so
    on: "*/1Min/OHLCV"
    config:
      filter: "nasdaq"
      destinations:
        - 5Min
        - 15Min
        - 1H
        - 1D
```

### 3.4 开发示例

```go
package main

import (
    "github.com/alpacahq/marketstore/v4/plugins/trigger"
    "github.com/alpacahq/marketstore/v4/utils/log"
)

type MyTrigger struct {
    config map[string]interface{}
}

// 必须实现的工厂函数
func NewTrigger(config map[string]interface{}) (trigger.Trigger, error) {
    return &MyTrigger{config: config}, nil
}

// 实现Trigger接口
func (t *MyTrigger) Fire(keyPath string, records []trigger.Record) {
    log.Info("Trigger fired for path: %s with %d records", keyPath, len(records))
    
    // 处理数据写入事件
    for _, record := range records {
        // 获取记录索引
        index := record.Index()
        // 获取数据负载
        payload := record.Payload()
        
        // 执行自定义逻辑
        t.processRecord(keyPath, index, payload)
    }
}

func (t *MyTrigger) processRecord(keyPath string, index int64, payload []byte) {
    // 实现您的业务逻辑
    // 例如：数据聚合、实时通知、数据验证等
}

func main() {
    // 插件入口点
}
```

## 4. BgWorker插件详解

### 4.1 接口定义

```go
// BgWorker实现Run()。它将在单独的goroutine中运行
type BgWorker interface {
    Run()
}

// 必须实现的工厂函数
func NewBgWorker(config map[string]interface{}) (BgWorker, error)
```

### 4.2 配置示例

```yaml
bgworkers:
  - module: gdaxfeeder.so
    name: datafeed
    config:
      symbols: ["BTC", "ETH", "LTC"]
      base_timeframe: "1Min"
      query_start: "2023-01-01 00:00"
```

### 4.3 开发示例

```go
package main

import (
    "time"
    "github.com/alpacahq/marketstore/v4/plugins/bgworker"
    "github.com/alpacahq/marketstore/v4/utils/log"
)

type MyWorker struct {
    config map[string]interface{}
    symbols []string
    interval time.Duration
}

// 必须实现的工厂函数
func NewBgWorker(config map[string]interface{}) (bgworker.BgWorker, error) {
    // 解析配置
    symbols, _ := config["symbols"].([]string)
    intervalStr, _ := config["interval"].(string)
    
    interval := time.Minute
    if intervalStr != "" {
        if parsed, err := time.ParseDuration(intervalStr); err == nil {
            interval = parsed
        }
    }
    
    return &MyWorker{
        config: config,
        symbols: symbols,
        interval: interval,
    }, nil
}

// 实现BgWorker接口
func (w *MyWorker) Run() {
    log.Info("Starting background worker with %d symbols", len(w.symbols))
    
    // 后台工作循环
    for {
        for _, symbol := range w.symbols {
            // 执行数据获取或处理
            w.fetchData(symbol)
        }
        
        // 等待下一次执行
        time.Sleep(w.interval)
    }
}

func (w *MyWorker) fetchData(symbol string) {
    // 实现数据获取逻辑
    // 例如：从API获取数据并写入MarketStore
    log.Info("Fetching data for symbol: %s", symbol)
}

func main() {
    // 插件入口点
}
```

## 5. 内置插件分析

### 5.1 OnDiskAgg插件（磁盘聚合）

**功能**：自动将低时间框架数据聚合到高时间框架

**核心实现**：
```go
type OnDiskAggTrigger struct {
    config       map[string]interface{}
    destinations timeframes
    filter       string
    aggCache     *sync.Map
}

func (s *OnDiskAggTrigger) Fire(keyPath string, records []trigger.Record) {
    // 1. 解析文件路径获取时间框架和年份
    elements := strings.Split(keyPath, "/")
    tf := utils.NewTimeframe(elements[1])
    
    // 2. 查询现有数据进行聚合
    csm, err := s.query(tbk, window, head, tail)
    
    // 3. 执行聚合计算
    cs2, err := aggregate(&slc, aggTbk, baseTbk, symbol)
    
    // 4. 写入聚合结果
    csm.AddColumnSeries(*aggTbk, cs2)
    executor.WriteCSM(csm, false)
}
```

**配置示例**：
```yaml
triggers:
  - module: ondiskagg.so
    on: "*/1Min/OHLCV"
    config:
      filter: "nasdaq"  # 可选：过滤市场时间
      destinations:
        - 5Min
        - 15Min
        - 1H
        - 1D
```

### 5.2 GDAXFeeder插件（数据源）

**功能**：从GDAX API获取加密货币历史价格数据

**核心实现**：
```go
type GdaxFetcher struct {
    config        map[string]interface{}
    symbols       []string
    queryStart    time.Time
    baseTimeframe *utils.Timeframe
}

func (gd *GdaxFetcher) Run() {
    client := gdax.NewClient("", "", "")
    
    for {
        for _, symbol := range symbols {
            // 1. 构建API请求参数
            params := gdax.GetHistoricRatesParams{
                Start:       timeStart,
                End:         timeEnd,
                Granularity: int(gd.baseTimeframe.Duration.Seconds()),
            }
            
            // 2. 获取历史数据
            rates, err := client.GetHistoricRates(symbol, params)
            
            // 3. 转换为MarketStore格式
            cs := io.NewColumnSeries()
            cs.AddColumn("Epoch", epoch)
            cs.AddColumn("Open", open)
            cs.AddColumn("High", high)
            cs.AddColumn("Low", low)
            cs.AddColumn("Close", clos)
            cs.AddColumn("Volume", volume)
            
            // 4. 写入数据库
            csm := io.NewColumnSeriesMap()
            tbk := io.NewTimeBucketKey(symbolDir + "/" + gd.baseTimeframe.String + "/OHLCV")
            csm.AddColumnSeries(*tbk, cs)
            executor.WriteCSM(csm, false)
        }
        
        // 5. 等待下一次获取
        time.Sleep(toSleep)
    }
}
```

## 6. 插件开发最佳实践

### 6.1 错误处理

```go
func (w *MyWorker) Run() {
    defer func() {
        if r := recover(); r != nil {
            log.Error("Worker panic recovered: %v", r)
            // 可以选择重启worker或记录错误
        }
    }()
    
    // 工作逻辑
}
```

### 6.2 配置验证

```go
func NewTrigger(config map[string]interface{}) (trigger.Trigger, error) {
    // 验证必需配置
    if symbols, ok := config["symbols"].([]string); !ok || len(symbols) == 0 {
        return nil, fmt.Errorf("symbols configuration is required and must be non-empty")
    }
    
    // 验证可选配置
    if interval, ok := config["interval"].(string); ok {
        if _, err := time.ParseDuration(interval); err != nil {
            return nil, fmt.Errorf("invalid interval format: %s", interval)
        }
    }
    
    return &MyTrigger{config: config}, nil
}
```

### 6.3 资源管理

```go
type MyWorker struct {
    config map[string]interface{}
    client *http.Client
    ticker *time.Ticker
}

func (w *MyWorker) Run() {
    // 初始化资源
    w.client = &http.Client{Timeout: 30 * time.Second}
    w.ticker = time.NewTicker(w.interval)
    defer w.ticker.Stop()
    
    for {
        select {
        case <-w.ticker.C:
            w.doWork()
        }
    }
}
```

### 6.4 日志记录

```go
import "github.com/alpacahq/marketstore/v4/utils/log"

func (t *MyTrigger) Fire(keyPath string, records []trigger.Record) {
    log.Info("Processing %d records for %s", len(records), keyPath)
    
    start := time.Now()
    defer func() {
        log.Info("Processed %d records in %v", len(records), time.Since(start))
    }()
    
    // 处理逻辑
}
```

## 7. 插件编译和部署

### 7.1 编译插件

```bash
# 编译Trigger插件
go build -buildmode=plugin -o mytrigger.so mytrigger.go

# 编译BgWorker插件
go build -buildmode=plugin -o myworker.so myworker.go
```

### 7.2 部署插件

```bash
# 将插件复制到GOPATH/bin目录
cp mytrigger.so $GOPATH/bin/
cp myworker.so $GOPATH/bin/

# 或者使用绝对路径
cp mytrigger.so /path/to/plugins/
```

### 7.3 配置文件

```yaml
# mkts.yml
root_directory: data
listen_port: 5993
grpc_listen_port: 5995
log_level: info

# Trigger插件配置
triggers:
  - module: mytrigger.so
    on: "*/1Min/OHLCV"
    config:
      symbols: ["AAPL", "GOOGL"]
      threshold: 100

# BgWorker插件配置
bgworkers:
  - module: myworker.so
    name: dataprocessor
    config:
      interval: "5m"
      batch_size: 1000
      api_key: "your_api_key"
```

## 8. 插件系统优势

### 8.1 模块化设计
- 核心功能与扩展功能分离
- 插件可以独立开发和测试
- 支持热插拔

### 8.2 类型安全
- 使用Go的接口系统确保类型安全
- 编译时检查接口实现
- 运行时类型验证

### 8.3 性能优化
- 插件运行在独立的goroutine中
- 支持并发处理
- 内存隔离

### 8.4 配置驱动
- 通过YAML配置文件管理插件
- 支持动态配置
- 环境变量支持

## 9. 常见问题和解决方案

### 9.1 插件加载失败

**问题**：插件无法加载
```bash
Error: unable to load NewTrigger
```

**解决方案**：
1. 检查插件文件是否存在
2. 确认插件编译正确
3. 验证GOPATH设置
4. 检查插件依赖

### 9.2 插件崩溃

**问题**：插件导致主服务崩溃
```bash
panic: runtime error: invalid memory address
```

**解决方案**：
1. 在插件中添加panic恢复
2. 避免直接访问内部API
3. 使用适当的错误处理
4. 隔离插件资源

### 9.3 性能问题

**问题**：插件影响系统性能
```bash
high CPU usage or memory leaks
```

**解决方案**：
1. 优化数据处理逻辑
2. 使用适当的缓存策略
3. 实现资源限制
4. 监控插件性能

## 10. 总结

MarketStore的插件系统提供了一个强大而灵活的扩展机制，允许开发者：

1. **快速集成**：通过简单的接口实现自定义功能
2. **高度定制**：支持各种数据源和处理逻辑
3. **性能优化**：针对金融时间序列数据优化
4. **易于维护**：模块化设计便于维护和升级

通过合理使用插件系统，可以大大扩展MarketStore的功能，满足各种复杂的金融数据处理需求。 